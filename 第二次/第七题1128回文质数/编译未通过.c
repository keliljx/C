/*
描述：因为151既是一个质数又是一个回文数(从左到右和从右到左看是一样的)，
所以151是回文质数．写一个程序来找出范围
[a,b](5<=a<b<=100,000,000)间的所有回文质数．
输入：第一行　两个整数：a和b．
输出：输出一个回文质数的列表，一行一个．
输入样例：5 500
输出样例：
5
7
11
101
131
151
181
191
313
353
373
383
题目分析：
1.多组测试数据，所以先打表。
2.先求质数再判断回文，效率低下；所以先构造回文数，再判断质数。
3.偶数位的回文数都能被11整除，自己证明去。所以，偶数位的回文数除了11都是合数。
4.一个k位数，可以构造出一个奇数位的回文数。比如13，可以构造131；189可以构造18981.所以100000000内的只要从1构造到9999即可。
5.若范围为1000000000，那么明显超出int范围，要用long long。当然此题无此陷阱。
6. 最后按从小到大的顺序输出，优先队列搞定。
*/
#include<stdio.h>

int huiwen(long long num)//回文质数判别函数
{

    int m=num,n=1;

    while(m)
    {
        m=m/10;
        n=n*10;
    }

    n=n/10;

    m=num;
     int i;
    for (i=n;i>=1;i/=100)//判断回文
    {
        if(m/i!=m%10)
            return 0;
        m=m-m/i*i;
        m=m/10;
    }

    for(i=2;i*i<=num;i++)//判断质数
    {
        if(num%i==0)
            return 0;
    }
    return 1;
}

int main()
{
    long long a,b;

    scanf("%lld%lld",&a,&b);

    if(a==1)
        a=a+1;

    if(b>10000000)  //偶数位回文数一定是11的倍数，所以一千万以上的都忽略
        b=10000000;
long long i;
    for(i=a;i<=b;i++)
        if(huiwen(i)==1)
            printf("%d\n",i);

    return 0;
}
